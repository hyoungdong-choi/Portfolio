# DevOps/Infra Engineer Portfolio

아래는 **GCP** 환경에서 시작해 **모니터링·로그**, **BI**, **이미지 처리**, **LLM**, **STT/TTS**, **LB 자동화**, 그리고 **클라우드 간 마이그레이션**까지 담당한 프로젝트입니다.

---

## 1. 모니터링 & 로그

### 개요
- **환경**: GCP 내 도커 기반 VM 인스턴스 서비스 및 로컬 서버 혼합 운영  
- **목표**: 시스템 상태를 실시간 파악하고 장애 징후를 조기에 인지해 서비스 중단 시간을 최소화

### 수행 내용
1. **Alertmanager - Google Chat 연동**  
   - **Prometheus**가 수집한 지표에 임계값 설정 → Alertmanager 알람  
   - 알람이 **Google Chat**으로 자동 전송되어 팀 전체가 즉각 공유
2. **DEV & STG 로그(Loki+promtail+Grafana)**  
   - 기존 ELK(EKF) 스택 시도 → 서비스 규모 대비 오버스펙이라 **Loki**로 전환  
   - Dev/Stage 환경에서는 **가벼운 로그 스택**으로 유지
3. **PROD 로그(GCP Logging)**  
   - **GCP Ops Agent**를 통해 프로덕션 로그를 수집  
   - GCP 네이티브 로깅을 활용해 알림·검색·대시보드 통합

### 성과 / 어려움 극복
- **성과**  
  - Dev/Stage와 Prod 환경을 구분함으로써 오버엔지니어링 방지  
- **어려움**  
  - 로그 툴 선정 -> 회사 인프라 규모 및 환경별 분리 하기 위해 로그 툴 장단점 파악 후 선정

---

## 2. BI (BigQuery & Looker)

### 개요
- **목적**: 앱 사용 현황을 시각화하여 마케팅 의사결정에 활용

### 수행 내용
1. **BigQuery 집계**  
   - 사용자 이벤트, 데이터 베이스 연결, 결제 로그 등을 주기적으로 적재  
   - 대규모 쿼리 시에도 빠른 응답 성능 확보
2. **Looker 대시보드**  
   - **KPI**(일활사용자, 신규 유저, 결제 및 재결제 정보 등)를 실시간 확인  
   - 권한별로 보고서·대시보드 접근을 세분화

### 성과 / 어려움 극복
- **성과**  
  - 데이터 분석 기반으로 기능 개선 로드맵 수립, 리소스 최적화 가능  
- **어려움**  
  - 로그 데이터 구성 복잡 → 스키마 설계·정제 프로세스 반복 개선

---

## 3. 이미지 이름 및 리사이징

### 개요
- **목적**: 모바일 앱 사용자들이 업로드하는 이미지가 너무 크거나, 동일 파일명으로 캐시 충돌이 빈번히 발생 → 자동화된 이미지 처리 필요

### 수행 내용
1. **이미지 캐시 충돌 방지**  
   - 파일명에 **UUID**나 **해시**를 부여해 중복 파일명 문제 해소  
   - HTTP 헤더(ETag, Cache-Control) 조정으로 캐시 효율성 확보
2. **이미지 자동 리사이징**  
   - 원본이 지나치게 큰 경우 **웹·모바일 최적 해상도**로 압축  
   - **WebP** 변환 적용해 용량 최소화, 초기 이미지 로드 속도 개선

### 성과 / 어려움 극복
- **성과**  
  - 이미지 용량 30~40% 절감, 업로드 실패율 감소  

---

## 4. LLM (Language Model) 테스트

### 개요
- **목적**: 모바일 앱 내 음성합성(STT)와 연계해 로컬 LLM 모델(가벼운 대화) 구현 시도  
- **모델**: **LLama**, **Gemma**, **phi4** 등 다양한 대규모 언어 모델

### 수행 내용
1. **LLM 모델 실험**  
   - 로컬 GPU 환경 및 클라우드 VM에서 Inference 테스트  
   - 응답 속도, 메모리 사용률, 대화 품질 등을 벤치마크  
2. **QLoRA 기법 & 양자화(4bit, 8bit)**  
   - 모델 크기 축소와 메모리 절감을 위해 **QLoRA** 및 **4bit/8bit 양자화** 적용  
   - 대규모 모델 전부를 학습하지 않고, 부분 가중치만 업데이트해 자원 절약

### 성과 / 어려움 극복
- **성과**  
  - LLM 기반 **대화형 프로토타입**(챗봇, 음성 명령 등) 구현 성공  
  - QLoRA + 4bit/8bit로 **GPU 메모리**·학습 비용 크게 절감  
- **어려움**  
  - Training 시 많은 GPU 리소스 사용으로 인해 OOM -> 초기 세팅 수정
  - 4bit 양자화 시 추론속도 향상이지만 정밀도 약간 손실 → 실 서비스 운용 시 적합한지 논의

---

## 5. STT & TTS 모델 테스트

### 개요
- **목적**: 음성 명령 인식(STT)과 합성(TTS)을 앱에 탑재하기 위한 사전 검증  
- **접근**: **TensorRT**, **Onnx** 변환을 통해 GPU·CPU 추론 엔진 최적화

### 수행 내용
1. **STT 모델 테스트**  
   - 음성 데이터셋으로 정확도·실시간 인식 성능 평가  
   - TensorRT/Onnx 기반 추론 최적화로 지연 시간 감소
2. **TTS 모델 검증**  
   - 합성 품질(음색 자연도) 평가
   - Onnx 변환 후 경량 서버 환경에서 실시간 TTS 시도

### 성과 / 어려움 극복
- **성과**  
  - 속도 중점의 모델 선정 후 속도 개선
- **어려움**  
  - 해당 모델이 GPU 마다 퍼포먼스 효율이 다름 -> GPU 별 변환 자동화 파이프라인 구성

---

## 6. GCP LB 자동화 스크립트 (Bash)

### 개요
- **목적**: **블루-그린 배포** 등 무중단 업데이트를 위해 인스턴스 탬플릿 및 인스턴스 그룹을 손쉽게 생성·변경할 수 있는 스크립트화 필요

### 수행 내용
1. **인스턴스 템플릿 & 그룹 자동 생성**  
   - GCP CLI를 이용해 **Bash 스크립트** 작성  
   - 블루·그린 인스턴스 그룹 각각 생성 후 LB와 연결
2. **Bash 스크립트 모듈화**  
   - 리전, 머신타입, 이미지명, 서버 사용자 스크립트 등 변수를 파라미터화  

### 성과 / 어려움 극복
- **성과**  
  - 서버 업데이트 시간 단축  
- **어려움**  
  - GCP CLI 버전 간 명령어 차이점으로 인해 오류 발생 -> 업데이트 체크 후 Bash 스크립트 수정

---

## 7. GCP → Azure 마이그레이션

### 개요
- **목적**: GCP에서 Azure 클라우드로 전환  
- **목표**: 다운타임 최소화, 기존 GCP 종속 서비스(Cloud Storage, GCR, Pub/Sub 등) 대안(Azure Blob, ACR, Service Bus 등) 매핑

### 수행 내용
1. **서비스 목록 파악 & 매핑**  
   - GCP Compute Engine → Azure VM  
   - GCS → Blob Storage, GCR → ACR, Pub/Sub → Service Bus 등  
   - DB, CI/CD, 모니터링 순으로 단계적 이전
2. **CI/CD 파이프라인 수정**  
   - Jenkins에서 GCP 환경(IP, 이미지 다운, Docker Env, Secret 등)을 Azure에 맞게 수정
3. **다운타임 최소화 전략**  
   - 사전 테스트 검증 후 다운타임 때 DB 및 Object Storage 마이그레이션 후 DNS 수정(Azure LB)

### 성과 / 어려움 극복
- **성과**  
  - 계획된 다운타임 내에 마이그레이션 성공, 큰 이슈 없이 안정화  
- **어려움**  
  - 네트워킹·권한 체계 차이 → 사전 테스트 및 명확한 문서화로 해결

---

## 결론

이와 같이 **음성합성(STT/TTS)**, **LLM**, **이미지 처리**, **BI**, **로깅·모니터링**, **LB 자동화** 및 **클라우드 간 마이그레이션** 등 전반적인 인프라와 AI 요소를 다루며, 다양한 문제 해결 경험을 쌓았습니다. 특히 GCP와 Azure 간 서비스를 비교·분석하고, 다양한 로깅 스택을 환경별로 운영하면서 DevOps 업무를 수행할 수 있었습니다.
